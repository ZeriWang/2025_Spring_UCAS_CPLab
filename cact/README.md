# CACT语言规范（2025版）

## 实验目标

通过一系列任务，完成CACT语言编译器的开发。

## 关于CACT语言

为C语言的迷你子集，设计受SysY2020启发。

> 注意：CACT不支持许多常见C特性，合法代码均以本规范为准。

---

## 词法规范

### 关键字

CACT对大小写敏感。关键字均小写，例如`if`是关键字，`IF`是标识符。

关键字表：

```
const   int        char  
float   void       if           else 
while   break      continue     return
```

### 基本类型

CACT 有三种基本类型：`int`，`float`，`char`。

#### 整数（int）

- 为32位有符号整数，支持以下整数常量格式：

1. **十进制**：除了“0”之外，十进制整数的首位数字不为0。如：`0`、`234`  
2. **八进制**：以整数0开头，后由0-7的数字组成，如：`000`、`0127`  
3. **十六进制**：以`0x`或`0X`开头，后由0-9、a-f、A-F中的数字组成。如：`0XFa32`  

> 数字与数字间没有如下划线'_'等分隔符，数字后也没有后缀。

#### 浮点数（float）

- 遵循IEEE754标准，有符号，支持两种形式。

1. **普通形式**：必须包含小数点，小数点的前或后必须有数字出现。如：`9.00`、`12.43`、`.5`、`8.f`  
   > 注意：整数加`f`后缀也不是浮点数，如`3f`算错误。

2. **指数形式**：必须依次出现基数、指数符号和指数三个部分。  
   - 指数符号为`E`或`e`；
   - 指数部分可带符号`+`或`-`（也可不带）后接数字组成。  
   - 如：`-43.0e-4F`、`3E2f`

#### 字符（char）

- 为有符号8位整数，字符常量由单引号包围：
  - 如：`'a'`、`'Z'`、`'0'`、`'+'`  
- 支持转义序列：
  - `'\n'`（换行）、`'\t'`（制表符）、`'\\'`（反斜杠）、`'\''`（单引号）、`'"'`（双引号）、`'\0'`（空字符）  
- 每个字符常量占用1个字节，以ASCII码存储。

> 不可以与其他类型进行算术运算。

---

## 运算符优先级（从高到低）

| 优先级 | 运算符       | 含义       | 结合方向 |
|--------|--------------|------------|----------|
| 1      | [...]        | 数组下标   | 左到右   |
|        | (...)        | 圆括号     |          |
| 2      | -            | 单目负号   | 右到左   |
|        | +            | 单目正号   |          |
|        | !            | 逻辑非     |          |
| 3      | * / %        | 乘除取余   | 左到右   |
| 4      | + -          | 加减       |          |
| 5      | <= >= < >    | 比较       |          |
| 6      | == !=        | 等价       |          |
| 7      | &&           | 逻辑与     |          |
| 8      | \|\|         | 逻辑或     |          |

---

## 标识符、空白与注释

- **标识符**：由大小写字母、数字及下划线组成，必须以字母或下划线开头。
- **空白符**：包括空格、Tab、空行，可出现在任何词法符号之间。
- **注释**：
  - 单行注释：`//` 开头，直到行末
  - 多行注释：`/* ... */`，不支持嵌套

---

## 文法规范

使用如下文法表示：

- `foo` 表示非终结符
- **Ident** 表示终结符
- `'foo'` 表示关键字
- `[...]` 可选（0次或1次）
- `{...}` 任意重复（0次及以上）
- `(...)` 分组
- `~(...)` 非
- `.` 任意字符
- `|` 或

### 声明 & 定义

```
编译单元 CompUnit → [ CompUnit ] ( Decl | FuncDef )

声明 Decl → ConstDecl | VarDecl

常量声明 ConstDecl → 'const' BType ConstDef { ',' ConstDef } ';'

基本类型 BType → 'int' | 'float' | 'char'

常量定义 ConstDef → Ident { '[' IntConst ']' } '=' ConstInitVal

初始值 ConstInitVal → ConstExp | '{' [ ConstInitVal { ',' ConstInitVal } ] '}'

变量声明 VarDecl → BType VarDef { ',' VarDef } ';'

变量定义 VarDef → Ident { '[' IntConst ']' } [ '=' ConstInitVal ]

函数定义 FuncDef → FuncType Ident '(' [FuncFParams] ')' Block

函数类型 FuncType → 'void' | 'int' | 'float' | 'char'

形参列表 FuncFParams → FuncFParam { ',' FuncFParam }

函数形参 FuncFParam → BType Ident [ '[' IntConst? ']' { '[' IntConst ']' } ]
```

### 语句 & 表达式

```
语句块 Block → '{' { BlockItem } '}'

语句块项 BlockItem → Decl | Stmt

语句 Stmt →
  LVal '=' Exp ';' |
  [ Exp ] ';' |
  Block |
  'return' Exp? |
  'if' '(' Cond ')' Stmt [ 'else' Stmt ] |
  'while' '(' Cond ')' Stmt |
  'break' ';' |
  'continue' ';'

表达式 Exp → AddExp

常量算式 ConstExp → AddExp

条件算式 Cond → LOrExp

左值算式 LVal → Ident { '[' Exp ']' }

数值 Number → IntConst | CharConst | FloatConst

函数实参表 FuncRParams → Exp { ',' Exp }

PrimaryExp → '(' Exp ')' | LVal | Number

UnaryExp →
  PrimaryExp |
  ('+' | '-' | '!') UnaryExp |
  Ident '(' [ FuncRParams ] ')'

MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp

AddExp → MulExp | AddExp ('+' | '-') MulExp

RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp

EqExp → RelExp | EqExp ('==' | '!=') RelExp

LAndExp → EqExp | LAndExp '&&' EqExp

LOrExp → LAndExp | LOrExp '||' LAndExp
```

> 注意：不支持连等、连续比较，条件表达式只在if/while中使用。

### 终结符定义

- Ident → (a-zA-Z_) { a-zA-Z0-9_ }
- NewLine → '\r' [ '\n' ] | '\n'
- WhiteSpace → { ' ' | '\t' }
- LineComment → '//' { 非换行 }
- BlockComment → '/*' { 任意字符 } '*/'
- IntConst → DecimalConst | OctalConst | HexadecConst
- DecimalConst → 非零数字 | 数字
- OctalConst → '0' | OctalConst 八进制数字
- HexadecConst → '0x'/'0X' 十六进制数字...
- CharConst → "'" character "'"
- FloatConst → 参见 ISO/IEC 9899 页57

---

## 语义规范

符合上述文法规范的代码集合，并不都是合法的CACT程序，而是CACT语言的超集。

下面进一步给出CACT语言的语义。

### 文件

每个CACT程序的源码存储在一个扩展名为cact的文件中。

CACT文件有且仅有一个标识为 `main`、无参数、返回类型为`int`的函数定义，`main`函数是程序运行的起始点。文件中还可以包含若干全局变量声明、常量声明和其他函数定义。

### 数组类型

CACT支持三种基本类型：`int`、`float`、`char`。CACT支持以基本类型为元素的多维数组，索引从`0`开始，以行优先顺序存储。如：`int a[M][N]`，其中M和N都是整数常量，通过`a[i][j]`方式访问，其中i取值范围`0`到`M-1`，`j`取值范围`0`到`N-1`。

数组可以在任何作用域中声明。函数声明中可以隐藏最外层维度，如`int f(int a[][N])`。除此之外，数组长度需要显式给出`IntConst`终结符，而不允许是变量。

### 初始化

每个变量/常量/数组在声明时都会被初始化，分为显式、隐式两种：

**显式初始化：**CACT限制初值表达式必须是常数，例如

```c
int a = 0;                           //合法
int b = a + 5;                    //非法
const int c = 4;                 //合法
const int d = 4 + 5;          //非法
float e = 1.5;                     //非法
float f = 3.2f;                    //合法
int a[4] = 4;                      //非法
int a[4] = {1,{2,3}};            //非法
int a[2][2] = {4, 5, 6};        //合法，数组内容为{ {4,5}, {6,0} }
int a[2][2] = {{4,5},{6,7}};   //合法
```

**隐式初始化：**未被显式初始化的整型和浮点型变量/常量/数组被默认初始化为0。

全局变量/常量/数组在程序开始执行时被初始化，局部数组在程序每次进入作用域时被重新初始化。

提示：由于CACT所有变量/常量、所有数组的各维都有确定的长度，所以不需要做堆管理。全局变量/常量/数组放置在静态数据区中，局部变量/常量/数组在栈上动态分配。

### 函数

C语言文法中定义了函数声明，这是为了函数调用可能出现的循环依赖而存在的：

为简单起见，CACT语言不考虑循环依赖的情况，函数声明永不孤立存在。保证在所有实例中，函数调用都会出现在函数定义之后。

```c
void a();

void b(){
  a();
}

void a(){
  b();
}
```

函数定义由返回类型、函数名、参数列表（可零）、函数体。下面作逐一说明：

1. 返回类型：只会是三种基本类型或`void`。
   - 基本类型：函数内所有路径都应当结束于`return Exp`的语句。如果路径不含有`return`语句，或`return`不含有表达式，则被认为是文法错误。
   - `void`：函数体中可以不包含`return`语句，如果有，不能包含返回值。
2. 函数名：与变量名要求相同。
3. 形参列表：可以包含0或多个形式参数。合法的形式参数类型分为以下两类。
   - 基本类型：三种基本类型，按值传递。
   - 数组类型：实际传递的是数组的起始地址，除了最外层维度外，各内层维度的长度需显式声明。
     - 显式情形：如`int a[A][M][N]`，则调用点传入数组各维度长度都需进行静态检查。
     - 隐式情形：如`int a[][M][N]`，最外层维度用一对中括号[]隐去，不检查调用点实际参数的最外层维度长度，但各内层维度长度需要进行静态检查。
4. 函数体：由若干变量声明和语句组成。

函数调用的执行过程包括以下几步：

1. 把函数调用点的实际参数值，作为初始值赋值给被调用函数的形式参数。实际参数的类型和个数，必须与形式参数相匹配。
2. 顺序执行被调用函数的函数体语句，遇到控制语句则依条件选择子语句执行。
3. 顺序执行直到 (1)`return`语句 或 (2)函数体结束 时，记录返回值并跳转到调用点的下一条语句。

### 标识符与作用域

CACT中，所有的标识符要求先定义再使用。

1. 常量/变量/数组：在使用前必须先声明。
2. 函数：必须在函数定义之后才能被调用，但允许递归调用。

标识符的定义-使用关系（Def-Use）由定义域规定。CACT语言支持三种作用域：

- 全局作用域：包括顶层变量/常量/函数定义。
- 函数作用域：包括函数定义中的形参，局部变量/常量。
- 局部作用域：由函数体内的语句块（Block）创建。

对程序的任意语句，都至少有两个有效的作用域：全局作用域和函数作用域。作用域存在嵌套关系：内层作用域可以隐藏掉外层作用域的同名标识符。嵌套关系用下面的例子进一步解释：

```c
const int a = 1;

void foo(){
  const int a = 2;

  {
    const int a = 3;
    // local scope, a = 3
  }

  if( a > 0 ){
    const int a = 4;
    // local scope, a = 4
  }

  // function scope, a = 2
}

int main(){
  foo();
  return a; // global scope, a = 1
}
```

**注意：**

1. 同一作用域中，同名变量的两次定义视为文法错误。
2. 在不违反上述条件下，变量名可与函数名相同。

### 控制语句

CACT中控制语句只有两种：`if(else)`语句和`while`语句，语义与C语言相同。

对于`if`语句：CACT中`if`语句遵循就近匹配原则。`else`匹配最近的`if`。用以下伪代码定义。

```c
if( 判断cond为真 ){
   执行if后面的语句(块);
} else if( 如果有else字句 ){
   执行else后面的语句(块); 
} else {
   跳过if后面的语句(块);
}
```

对于`while`语句：判断`cond`为真，则执行`while`后面的语句(块)，并无条件跳转回到`cond`；否则，跳过`while`后面的语句(块)。

### 左值与赋值

左值是可以出现在赋值语句左边的值，因此得名。CACT支持两种左值：变量与数组元素。每个左值都属于三种基本类型之一。

对于赋值语句，CACT完全采用值拷贝语义，`LVal=Exp`语句把`Exp`的值拷贝到`LVal`中，要求`LVal`与`Exp`类型必须完全相同。再次注意，CACT不支持任何形式的类型转换。

此外，在函数体中允许对形式参数进行再次赋值，只在该函数的作用域内有效，不会改变调用者传入参数的值。

### 运算

CACT支持基本的算术运算（`+`、`-`、 `*`、`/`、`%`）、相等性运算（`==`、`!=`）、关系运算（`<`、`>`、`<=`、`>=`）和逻辑运算（`!`、`&&`、`||`），语义与C语言相同。保证样例中不出现连等（`a==b==c`）。

在CACT中，逻辑非运算符(`!`)只对布尔类型的变量及表达式使用，取余运算(`%`)不支持浮点数。

示例（错误）：

```c
int main(){
  const int a = 1;
  int a = 2; // wrong!
  return a;
}
```